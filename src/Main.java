
/*
Вам даны n задач, помеченные от 0 до n - 1, представленные двумерным целочисленным массивом tasks,
где это означает: tasks[i] = [Время постановки в очередь, время обработки]
У вас есть однопоточный процессор, который может обрабатывать не более одной задачи за раз и действует
следующим образом:
- Если ЦП простаивает и нет доступных задач для обработки, ЦП остается бездействующим.
- Если ЦП простаивает и есть доступные задачи, ЦП выберет ту, которая имеет наименьшее время обработки .
- Если несколько задач имеют одинаковое наименьшее время обработки, будет выбрана задача с
наименьшим индексом.
- После запуска задачи ЦП будет обрабатывать всю задачу без остановки.
- ЦП может завершить задачу, а затем мгновенно начать новую.
Нужно вернуть порядок, в котором ЦП будет обрабатывать задачи.
Пример 1:
Входные данные: задачи = [[1,2],[2,4],[3,2],[4,1]]
 Выходные данные: [0,2,3,1]
 Объяснение: События происходят следующим образом:
- При time = 1, задача 0 доступна для обработки. Доступные задачи = {0}.
- Также в момент времени = 1 простаивающий ЦП начинает обработку задачи 0. Доступные задачи = {}.
- В момент времени = 2 задача 1 доступна для обработки. Доступные задачи = {1}.
- В момент времени = 3 задача 2 доступна для обработки. Доступные задачи = {1, 2}.
- Также в момент времени = 3 ЦП завершает задачу 0 и начинает обработку задачи 2, поскольку она самая короткая. Доступные задачи = {1}.
- В момент времени = 4 задача 3 доступна для обработки. Доступные задачи = {1, 3}.
- В момент времени = 5 ЦП завершает задачу 2 и начинает обработку задачи 3, поскольку она самая короткая. Доступные задачи = {1}.
- В момент времени = 6 ЦП завершает задачу 3 и начинает обработку задачи 1. Доступные задачи = {}.
- В момент времени = 10 ЦП завершает задачу 1 и переходит в режим ожидания.
Пример 2:
Ввод: задачи = [[7,10],[7,12],[7,5],[7,4],[7,2]]
 Выход: [4,3,2,0,1]
 Объяснение : События происходят следующим образом:
- На время = 7 все задания становятся доступными. Доступные задачи = {0,1,2,3,4}.
- Также в момент времени = 7 простаивающий ЦП начинает обработку задачи 4. Доступные задачи = {0,1,2,3}.
- В момент времени = 9 ЦП завершает задачу 4 и начинает обработку задачи 3. Доступные задачи = {0,1,2}.
- В момент времени = 13 ЦП завершает задачу 3 и начинает обработку задачи 2. Доступные задачи = {0,1}.
- В момент времени = 18 ЦП завершает задачу 2 и начинает обработку задачи 0. Доступные задачи = {1}.
- В момент времени = 28 ЦП завершает задачу 0 и начинает обработку задачи 1. Доступные задачи = {}.
- В момент времени = 40 ЦП завершает задачу 1 и переходит в режим ожидания.
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        int[][] mass = {{7,10},{7,12},{7,5},{6,5},{7,2}};

        findTest(mass);

        }
        public static void findTest(int[][] mass){
            int min = Integer.MAX_VALUE;
            int minLastElementArrayIndex = -1;
            for (int i = 0; i < mass.length; i++) {
                int[] curr = mass[i];
                int lastIndex = curr[curr.length-1];
                if (lastIndex < min){
                    min = lastIndex;
                    minLastElementArrayIndex = i;
                }
                else if (lastIndex == min){
                    // Если последние элементы равны, сравниваем первые элементы
                    int firstElementCurrent = curr[0];
                    int firstElementSmallest = mass[minLastElementArrayIndex][0];
                    if (firstElementCurrent < firstElementSmallest){
                        minLastElementArrayIndex = i;
                    }
                }
            }
            if (minLastElementArrayIndex != -1){
                System.out.println("Номер массива с самым маленьким последним элементом: " + minLastElementArrayIndex);
                System.out.println("Массив с самым маленьким последним элементом: " + Arrays.toString(mass[minLastElementArrayIndex]));
                System.out.println("Значение последнего элемента: " + min);

                int[][] newArr = getNewArr(mass, minLastElementArrayIndex);

                findTest(newArr);

            } else {
                // Если не найдено, выводим сообщение
                System.out.println("=========");
                System.out.println("Массивов нет или ошибка в данных");
            }
        }

    private static int[][] getNewArr(int[][] mass, int minLastElementArrayIndex) {
        int[][] newArr = new int[mass.length - 1][];
        for (int i = 0, k = 0; i < mass.length; i++) {
            if (i == minLastElementArrayIndex) {
                continue;
            }
            newArr[k++] = mass[i];
        }
        return newArr;
    }
}

